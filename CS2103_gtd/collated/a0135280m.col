//@author: a0135280m



	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\AddCommand.java
	 */

public class AddCommand implements Command {

    Storage storage;
    History history;
	Task[] tasksToAdd;
	int[] taskIds;
	
	public AddCommand(Storage _storage, History _history, Task[] _tasks) {
	    storage = _storage;
	    history = _history;
		tasksToAdd = _tasks;
		taskIds = new int[tasksToAdd.length];
	}
	
	@Override
	public String execute() {
		String userFeedback = "";
		for (int i=0; i<tasksToAdd.length; i++) {
		    userFeedback += "\n" + storage.add(tasksToAdd[i]);
		    taskIds[i] = tasksToAdd[i].getId();
		}
		updateHistory();
		return Constants.MESSAGE_ADDED +"\n"+ Constants.DISPLAY_TABLE_HEADERS + userFeedback;
	}
	
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\AddCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\ClearCommand.java
	 */

public class ClearCommand implements Command {

	Storage storage;
	History history;
	Task[] deletedTasks;

	public ClearCommand(Storage _storage, History _history) {
		storage = _storage;
		history = _history;
	}

	@Override
	public String execute() {
		deletedTasks = storage.getAllTasks();
		String feedback = storage.deleteAll();
		updateHistory();
		return feedback;
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\ClearCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\CommandType.java
	 */

public enum CommandType {
    ADD, DISPLAY, DONE, UNDONE, DELETE, EDIT, UNDO, REDO, HELP, SETDIR, GETDIR, EXIT, 
    INVALID, SEARCH, CLEAR
}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\CommandType.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Constants.java
	 */

public final class Constants {
    
    // Feedback messages
	public static final String MESSAGE_ADDED = "Added new Task:";
	public static final String MESSAGE_DELETED = "Task nr %1$d has been deleted";
	public static final String MESSAGE_UPDATED = "Tasks have been updated:";
	public static final String MESSAGE_ALL_DELETED = "All tasks are now deleted";
	public static final String MESSAGE_NO_TASKS = "You have currently no tasks to show.";
	public static final String MESSAGE_WELCOME = "Welcome to TaskWaltz!";
    public static final String MESSAGE_FILE_CHANGE = "The file %1$s is now used for storing tasks";
    public static final String MESSAGE_EDIT_ORIGINAL = "Original Task:";
    public static final String MESSAGE_EDIT_CHANGE = "Changed to:";
    public static final String MESSAGE_TIME_PERIOD = "DISPLAY TASKS FROM %1$s TO %2$s\n";
    public static final String MESSAGE_DISPLAY_ALL = "DISPLAY ALL TASKS\n";
	
	// Error Messages
    public static final String MESSAGE_GENERAL_ERROR = "Something went wrong";
    public static final String MESSAGE_INITIALIZATION_ERROR = "There was a problem opening TaskWaltz";
    public static final String MESSAGE_COMMAND_EXECUTION_ERROR = "TaskWaltz was not able to execute the following command: ";
	public static final String MESSAGE_NO_UNDO = "No commands to undo";
	public static final String MESSAGE_NO_REDO = "No commands to redo";
	public static final String MESSAGE_INVALID_INPUT = "Invalid Input";
	public static final String MESSAGE_INCORRECT_ID = "Provided Task ID(s) was(were) either non-existent or in invalid format";
    public static final String MESSAGE_NO_DONE_TAKS = "You have no done tasks to delete";
    public static final String MESSAGE_NO_VALID_IDs = "No task(s) corresponding to the requested ID(s) could be found.";
    public static final String MESSAGE_ERROR_SET_DICT = "The file name was not input correctly";
    public static final String MESSAGE_SEARCH_UNSUCCESSFUL = "No tasks matched your search criterias";
    public static final String MESSAGE_UNSUCCESSFUL_FILE_CHANGE = "The storage path could not be changed to %1$s";
    public static final String MESSAGE_ERROR_CONFIG_FILE = "TaskWaltz was not able to retrieve your data. Check your directory path in config.txt";
    public static final String MESSAGE_ERROR_NOT_JSON = "Please specify the directory, file name and extension(.json)";
    
	// Formatting
    public static final String DISPLAY_TASK_FORMAT = "%-4d%-8s%-5s%-23s%-23s%s";
	public static final String FORMAT_DISPLAY_TASKINFO = "\nTaskID: %1$d\n%2$s\nStart: %3$s\nEnd: %4$s\n";
	public static final DateTimeFormatter FORMAT_STORAGE_DATETIME = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
    public static final String DISPLAY_TABLE_HEADERS = "\n" + String.format("%-4s%-8s%-5s%-23s%-23s%s", "ID", "Status","Done", "Start (DD-MM-YYYY)", "End (DD-MM-YYYY)", "Description");
	public static final String DISPLAY_DONE = "[x]";
	public static final String DISPLAY_UNDONE = "[ ]";
	public static final String DISPLAY_OVERDUE = "overdue";
	public static final String DISPLAY_TIME_NOW = "NOW";
	public static final String EDIT_FORMAT = "%-15s%s";
	
	
	// Numbers
	public static final int NO_ID_GIVEN = -1;
	public static final int INCLUDED_IN_SEARCH = 1;
	public static final int NOT_INCLUDED_IN_SEARCH = 0;
	
	//Default values
	public static final String DEFAULT_STORAGE_PATH = "storage_file.json";
    
    // Help
    public static final String MESSAGE_HELP = "Available commands:\n"
            + "add <description> <start time (if any)> <end time(if any)>\n  equivalent: a\n\n"
            + "delete <task identification number(s)>\n  equivalent: remove, rm, del\n\n"
            + "display\n  equivalent: dis, show, ls\n\n"
            + "done <task identification number(s)>\n  equivalent: do\n\n"
            + "edit <task identification number> <new parameters>\n  equivalent: e\n\n"
            + "exit\n\n"
            + "getdirectory <file path>\n  equivalent: getdir\n\n"
            + "help\n\n"
            + "redo\n  equivalent: r\n\n"
            + "search <Keyword>\n  equivalent: s\n\n"
            + "setdirectory <file path>\n  equivalent: setdir\n\n"
            + "undo\n  equivalent: u\n\n"
            + "undone <task identification number(s)>";
}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Constants.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DeleteCommand.java
	 */

public class DeleteCommand implements Command {

	Storage storage;
	History history;
	int[] taskIds;
	Task[] deletedTasks;

	public DeleteCommand(Storage _storage, History _history, int[] _taskIds) {
		storage = _storage;
		history = _history;
		taskIds = _taskIds;
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DeleteCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DeleteDoneCommand.java
	 */

public class DeleteDoneCommand implements Command {
    
    Storage storage;
    History history;
    Task[] deletedTasks;
    
    public DeleteDoneCommand(Storage _storage, History _history) {
        storage = _storage;
        history = _history;
    }
    
    @Override
    public String execute() {
        ArrayList<Task> doneTasksList = new ArrayList<Task>();
        String userFeedback = "";
        Task[] allTasks = storage.getAllTasks();
        for (Task task : allTasks) {
            if (task.isDone()) {
                doneTasksList.add(task);
                userFeedback += storage.delete(task.getId()) + "\n";
            }
        }
        if (doneTasksList.size() > 0) {
            deletedTasks = new Task[doneTasksList.size()];
            deletedTasks = doneTasksList.toArray(deletedTasks);
            updateHistory();
            return userFeedback;
        } else {
            return Constants.MESSAGE_NO_DONE_TAKS;
        }
    }
    
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DeleteDoneCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DisplayCommand.java
	 */

public class DisplayCommand implements Command {

	Storage storage;
	Task displayObj;

	public DisplayCommand(Storage _storage, Task _displayObj) {
		storage = _storage;
		displayObj = _displayObj;
	}

	@Override
	public String execute() {
		String displayFeedback = "";
		if (displayObj != null) {
			if (displayObj.isDone() == true) {
				displayFeedback = storage.getDoneTasksAsString();
			} else if (isDisplayAllCommand()) {
				displayFeedback = storage.getAllTasksAsString();
			} else {
				displayFeedback = storage.getTasksInTimeSpan(displayObj);
			}
		} else {
			displayFeedback = "Invalid display command";
		}
		return displayFeedback;
	}
	
	private boolean isDisplayAllCommand() {
	    LocalDateTime start = displayObj.getStartDateTime();
	    LocalDateTime end = displayObj.getEndDateTime();
	    return start.equals(LocalDateTime.MIN) && end.equals(LocalDateTime.MAX);
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DisplayCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DoneCommand.java
	 */

public class DoneCommand implements Command {

	int[] taskIds;
	boolean setDone;
	Storage storage;
	History history;

	public DoneCommand(Storage _storage, History _history, int[] _ids,
			boolean _setDone) {
		taskIds = _ids;
		setDone = _setDone;
		history = _history;
		storage = _storage;
	}

	@Override
	public String execute() {
		String userFeedback = "";
		for (int id : taskIds) {
			if (userFeedback.equals("")) {
				userFeedback += storage.done(id, setDone);
			} else {
				userFeedback += "\n" + storage.done(id, setDone);
			}

		}
		updateHistory();
		return Constants.MESSAGE_UPDATED +"\n"+ Constants.DISPLAY_TABLE_HEADERS +"\n"+userFeedback;
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\DoneCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\GetDirectoryCommand.java
	 */

public class GetDirectoryCommand implements Command {

	Storage storage;

	public GetDirectoryCommand(Storage _storage) {
		storage = _storage;
	}

	@Override
	public String execute() {
		String filePath = storage.getFilePath();
		return filePath;
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\GetDirectoryCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\HelpCommand.java
	 */

public class HelpCommand implements Command {

	public HelpCommand() {

	}

	@Override
	public String execute() {
		return Constants.MESSAGE_HELP;
	}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\HelpCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\SearchCommand.java
	 */

public class SearchCommand implements Command {

	Task searchObj;
	Storage storage;

	public SearchCommand(Storage _storage, Task _searchObj) {
		searchObj = _searchObj;
		storage = _storage;
	}

	@Override
	public String execute() {
		String searchFeedback = storage.search(searchObj);
		return searchFeedback;
	}
	
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\SearchCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\SetDirectoryCommand.java
	 */

public class SetDirectoryCommand implements Command {

    Storage storage;
    History history;
    private String newDir;
	private String oldDir;
	
	public SetDirectoryCommand(Storage _storage, History _history, String path) {
		newDir = path;
		storage = _storage;
		history = _history;
	}

	@Override
	public String execute() {
	    oldDir = storage.getFilePath();
		String feedback;
		try {
			feedback = storage.setFilePath(newDir);
		} catch (IOException e) {
			return e.getMessage();
		}
		updateHistory();
		return feedback;
	}

	@Override
	public Command makeUndo() {
		return new SetDirectoryCommand(storage, history, oldDir);
	}

	@Override
	public void updateHistory() {
		history.pushUndo(makeUndo());
		
	}

}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\SetDirectoryCommand.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Storage.java
	 */

public class Storage {
    
    private Map<Integer, Task> tasks;
    private StorageIO storageIO;
    private StorageSearch storageSearch;
    private int lastIdNumber;
    
    public Storage(StorageIO _storageIO) {
        storageIO = _storageIO;
    }
    /**
     * Initialize StorageSerach and StorageIO, file paths and the data structure
     * for storing tasks.
     * 
     * @return feedback string
     */
    public String prepareStorage() throws IOException {
        storageSearch = new StorageSearch();
        String storageFilePath = storageIO.initializeConfigFile();
        String setStorageFileFeedback = storageIO.setFilePath(storageFilePath);
        initializeTaskList();
        return setStorageFileFeedback;
    }

    /**
     * Create a HashMap with Tasks and their id as key from the storage file
     */
    private void initializeTaskList() {
        tasks = new HashMap<Integer, Task>();
        storageIO.getDataFromFile(tasks);
        lastIdNumber = storageIO.getLastIdNumber();
    }

    /**
     * Change the path for task storage and updates the tasks
     * 
     * @param path  the new path given by the user
     * @return      feedback string
     */
    public String setFilePath(String path) throws IOException {
        String feedback = storageIO.setFilePath(path);
        initializeTaskList();
        return feedback;
    }
    
    public String getFilePath() {
        return storageIO.getFilePath();
    }

    private int getNextIdNo() {
        lastIdNumber++;
        return lastIdNumber;
    }
    
    public String add(Task newTask) {
        int taskId = newTask.getId();
        if (taskId == Constants.NO_ID_GIVEN) {
            taskId = getNextIdNo();
            newTask.setId(taskId);
        }
        tasks.put(taskId, newTask);
        writeToFile();
        return newTask.getUserFormat();
    }
    
    public String delete(int id) {
        assert id > 0;
        Task removedTask = tasks.get(id);
        if (removedTask != null) {
            tasks.remove(id);
            writeToFile();
            return String.format(Constants.MESSAGE_DELETED, removedTask.getId());
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    public String deleteAll() {
        tasks = new HashMap<Integer, Task>();
        writeToFile();
        return String.format(Constants.MESSAGE_ALL_DELETED);
    }
    
    public String done(int id, boolean setDone) {
        if (tasks.get(id) != null) {
            Task doneTask = tasks.get(id);
            doneTask.setDone(setDone);
            tasks.put(id, doneTask);
            writeToFile();
            return doneTask.getUserFormat();
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    private String updateTask(int id, Task updatedTask) {
        if (tasks.get(id) != null) {
            tasks.put(id, updatedTask);
            writeToFile();
            return String.format(Constants.MESSAGE_UPDATED, id);
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    public String updateDescription(int id, String newDesc) {
        Task taskToUpdate = tasks.get(id);
        if (taskToUpdate != null) {
            taskToUpdate.setDescription(newDesc);
            return updateTask(id, taskToUpdate);
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    public String updateStartDate(int id, LocalDateTime startDate) {
        Task taskToUpdate = tasks.get(id);
        if (taskToUpdate != null) {
            taskToUpdate.setStartDateTime(startDate);
            return updateTask(id, taskToUpdate);
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    public String updateEndDate(int id, LocalDateTime endDate) {
        Task taskToUpdate = tasks.get(id);
        if (taskToUpdate != null) {
            taskToUpdate.setEndDateTime(endDate);
            return updateTask(id, taskToUpdate);
        }
        return Constants.MESSAGE_INCORRECT_ID;
    }
    
    public Task getTask(int id) {
        if (tasks.get(id) != null) {
            return tasks.get(id);
        }
        return null;
    }
    
    public Task getLastAddedTask() {
        return getTask(lastIdNumber);
    }
    
    /**
     * Returns array with all tasks
     */
    public Task[] getAllTasks() {
        Task[] taskArray = new Task[tasks.size()];
        int i = 0;
        for (Task task : tasks.values()) {
            taskArray[i] = task;
            i++;
        }
        return taskArray;
    }
    
    /**
     * Returns a string with all task information formatted as a table with the 
     * done tasks at the top, then floating tasks and last the unfinished 
     * deadline and event tasks, ordered by date. 
     * 
     * @return  all tasks as a user friendly formatted string 
     */
    public String getAllTasksAsString() {
        String allTasks = getDoneTasksAsString();
        
        ArrayList<Task> unfinishedTasks = getUnfinishedTasks();
        for (Task newTask : unfinishedTasks) {
            allTasks += "\n" + newTask.getUserFormat();
        }
        
        if (allTasks.equals("")) {
            return Constants.MESSAGE_NO_TASKS;
        }
        String feedback = "\n" + Constants.MESSAGE_DISPLAY_ALL + 
                Constants.DISPLAY_TABLE_HEADERS + allTasks;
        return feedback;
    }
    
    /**
     * Returns all unfinished tasks ordered by date (closest deadline at the 
     * bottom) and with floating tasks at the top
     * 
     * @return  ArrayList with unfinished tasks
     */
    private ArrayList<Task> getUnfinishedTasks() {
        Task[] taskArray = getAllTasks();
        ArrayList<Task> unfinishedTasks = new ArrayList<Task>();
        for (Task task : taskArray) {
            if (!task.isDone()) {
                unfinishedTasks.add(task);
            }
        }
        Collections.sort(unfinishedTasks);
        return unfinishedTasks;
    }
    
    /**
     * Returns a string with all tasks in a given time span, formatted as a 
     * table with the done tasks at the top, then floating tasks and last the 
     * unfinished deadline and event tasks, ordered by date. 
     * 
     * @param displayObj    Task with the given time span as startDateTime and 
     *                      endDateTime
     * @return tasks in the time span as a user friendly formatted string 
     */
    public String getTasksInTimeSpan(Task displayObj) {
        String displayTasks = "\n";
        displayTasks += getDisplayTitle(displayObj);
        
        ArrayList<Task> unfinishedTasks = getUnfinishedTasks();        
        String searchResult = storageSearch.search(unfinishedTasks, displayObj);
        String floatingTasks = getFloatingTasksAsString();
        
        if (searchResult == "" && floatingTasks == "") {
            displayTasks += Constants.MESSAGE_NO_TASKS;
        } else {
            displayTasks += Constants.DISPLAY_TABLE_HEADERS;
            displayTasks += floatingTasks;
            displayTasks += searchResult;
        }
        
        return displayTasks;
    }
    
    private String getDisplayTitle(Task displayObj) {
        String startTime;
        String endTime;
        if (displayObj.isDeadlineTask()) {
            startTime = Constants.DISPLAY_TIME_NOW;
        } else {
            startTime = displayObj.getStartDateForDisplay();
        }
        endTime = displayObj.getEndDateForDisplay();
        return String.format(Constants.MESSAGE_TIME_PERIOD, startTime, endTime);
    }
    
    public String getDoneTasksAsString() {
        String doneTasksString = "";
        for (Task task : tasks.values()) {
            if (task.isDone()) {
                doneTasksString += "\n" + task.getUserFormat();
            }
        }
        return doneTasksString;
    }
    
    private String getFloatingTasksAsString() {
        String floatingTasksString = "";
        for (Task task : tasks.values()) {
            if (task.isFloatingTask() && !task.isDone()) {
                floatingTasksString += "\n" + task.getUserFormat();
            }
        }
        return floatingTasksString;
    }
    
    /**
     * Make a search given the search criterias in the searchObj
     * 
     * @param searchObj
     * @return the search result as a string
     */
    public String search(Task searchObj) {
        String feedback;
        ArrayList<Task> taskList = new ArrayList<Task>(tasks.values());
        String result = storageSearch.search(taskList, searchObj);
        if (result.equals("")) {
            feedback = Constants.MESSAGE_SEARCH_UNSUCCESSFUL;
        } else {
            feedback = Constants.DISPLAY_TABLE_HEADERS+"\n"+result;
        }
        return feedback;
    }
    
    public void writeToFile() {
        storageIO.writeToFile(tasks);
    }

}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Storage.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageIO.java
	 */

public class StorageIO {

	private String storageFilePath;
	private String configFilePath;
	private int lastIdNumber;

	public String getFilePath() {
		return storageFilePath;
	}

	/**
	 * Get the storage file path if any saved in the config file, otherwise 
	 * create a new one.
	 * @return the storage file path
	 */
	public String initializeConfigFile() throws IOException {
		configFilePath = System.getProperty("user.dir") + "/config.txt";
		File file = new File(configFilePath);
		String storageFilePath = "";
		try {
			if (!file.exists()) {
				file.createNewFile();
				storageFilePath = getDefaultStoragePath();
			} else {
				BufferedReader br = new BufferedReader(new FileReader(
						configFilePath));
				storageFilePath = br.readLine();
				br.close();
				if (storageFilePath == null) {
					storageFilePath = getDefaultStoragePath();
				}
			}
		} catch (IOException e) {
			throw new IOException(Constants.MESSAGE_ERROR_CONFIG_FILE);
		}
		return storageFilePath;
	}

	private String getDefaultStoragePath() {
		return System.getProperty("user.dir") + "/"
				+ Constants.DEFAULT_STORAGE_PATH;
	}

	/**
	 * Set a new storage file path and save it to the config file
	 * @param path     the new storage file path
	 */
	public String setFilePath(String path) throws IOException {
		if (!path.contains(".json")) {
			return Constants.MESSAGE_ERROR_NOT_JSON;
		}
		storageFilePath = path;
		File file = new File(storageFilePath);
		try {
			if (!file.exists()) {
				file.createNewFile();
			}
			File configFile = new File(configFilePath);
			configFile.createNewFile(); // to remove the old config file if any
			BufferedWriter output = new BufferedWriter(new FileWriter(
					configFile));
			output.write(path); // write the storage file path
			output.flush();
			output.close();
			return String
					.format(Constants.MESSAGE_FILE_CHANGE, storageFilePath);
		} catch (IOException e) {
			throw new IOException(
					"TaskWaltz was not able to set your directory to " + path);
		}

	}

	public int getLastIdNumber() {
		return lastIdNumber;
	}

	/**
	 * Turn the task objects into JSON and save to file
	 */
	public void writeToFile(Map<Integer, Task> tasks) {
		JSONObject jsonObj = new JSONObject();

		JSONArray jsonArray = new JSONArray();
		for (Task task : tasks.values()) {
			JSONObject taskObj = new JSONObject();
			String desc = task.getDescription();
			taskObj.put("desc", desc);
			String startDateTime = task.getStartDateTimeInString();
			taskObj.put("startDate", startDateTime);
			String endDateTime = task.getEndDateTimeInString();
			taskObj.put("endDate", endDateTime);
			String done = task.isDone() + "";
			taskObj.put("done", done);
			jsonArray.put(taskObj);
		}

		jsonObj.put("tasks", jsonArray);

		try {
			FileWriter file = new FileWriter(storageFilePath);
			file.write(jsonObj.toString());
			file.flush();
			file.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Read data from the storage file and create Task objects
	 */
	public void getDataFromFile(Map<Integer, Task> tasks) {
		String jsonStr = "";
		try {
			BufferedReader br = new BufferedReader(new FileReader(
					storageFilePath));
			String line = br.readLine();
			while (line != null) {
				jsonStr += " " + line;
				line = br.readLine();
			}
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		if (jsonStr.length() > 0) {
			createTasksFromJson(jsonStr, tasks);
		}

	}

	private void createTasksFromJson(String jsonStr, Map<Integer, Task> tasks) {
		JSONObject jsonObj = new JSONObject(jsonStr);
		JSONArray jsonArr = jsonObj.getJSONArray("tasks");
		lastIdNumber = 0;
		for (int i = 0; i < jsonArr.length(); i++) {
			JSONObject currentObj = jsonArr.getJSONObject(i);
			String desc = currentObj.getString("desc");
			String startDateString = currentObj.getString("startDate");
			LocalDateTime startDate = null;
			if (!startDateString.equals("")) {
				startDate = converteToDate(startDateString);
			}
			String endDateString = currentObj.getString("endDate");
			LocalDateTime endDate = null;
			if (!endDateString.equals("")) {
				endDate = converteToDate(endDateString);
			}
			boolean done = currentObj.getBoolean("done");
			lastIdNumber++;
			Task newTask = new Task(lastIdNumber, desc, startDate, endDate,
					done);
			tasks.put(lastIdNumber, newTask);
		}
	}

	private LocalDateTime converteToDate(String strDate) {
		return LocalDateTime.parse(strDate, Constants.FORMAT_STORAGE_DATETIME);
	}

}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageIO.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageIoMock.java
	 */

public class StorageIoMock extends StorageIO {
    
    private String storageFilePath;
    private int lastIdNumber;
    
    public String getFilePath() {
        return storageFilePath;
    }
    
    public String initializeConfigFile() {
        storageFilePath = getDefaultStoragePath();
        return storageFilePath;
    }
    
    private String getDefaultStoragePath() {
        return System.getProperty("user.dir") + "/" + Constants.DEFAULT_STORAGE_PATH;
    }
    
    public String setFilePath(String path) {
        storageFilePath = path;
        return String.format(Constants.MESSAGE_FILE_CHANGE, storageFilePath);
    }
    
    public int getLastIdNumber() {
        return lastIdNumber;
    }
    
    public void writeToFile(Map<Integer, Task> tasks) {
        
    }
    
    public void getDataFromFile(Map<Integer, Task> tasks) {
        
    }
    
}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageIoMock.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageSearch.java
	 */

public class StorageSearch {
    
    /**
     * Goes through the given task list and checks which tasks that both includes
     * the search word and is inside the search span. 
     * @param taskList: ArrayList of tasks to be checked
     * @param searchObj: Task object containing all search criterias
     * @return String with the found tasks in a user readable format
     */
    public String search(ArrayList<Task> taskList, Task searchObj) {
        Collections.sort(taskList);
        int[] foundTasks = new int[taskList.size()];
        
        foundTasks = searchOnKeyword(taskList, searchObj, foundTasks);
        foundTasks = searchOnDate(taskList, searchObj, foundTasks);

        String searchResult = "";
        for (int i=0; i<foundTasks.length; i++) {
            if (foundTasks[i] == Constants.INCLUDED_IN_SEARCH) {
                Task newTask = taskList.get(i);
                searchResult += "\n" + newTask.getUserFormat();
            }
        }
        return searchResult;
    }
    
    /**
     * Checks which tasks that includes the search word in their description
     * @param tasks: ArrayList of tasks to search from
     * @param searchObj: Task object containing the search criterias
     * @param foundTasks: Binary array with 1s for the tasks which still meets 
     * the search criteria and 0s for those who don't
     * @return the updated foundTasks array
     */
    private int[] searchOnKeyword(ArrayList<Task> tasks, Task searchObj, 
            int[] foundTasks) {
        String keyword = searchObj.getDescription();
        for (int i=0; i<tasks.size(); i++) {
            Task task = tasks.get(i);
            String taskDesc = task.getDescription();
            if (taskDesc.toLowerCase().contains(keyword.toLowerCase())) {
                foundTasks[i] = Constants.INCLUDED_IN_SEARCH;
            }
        }
        return foundTasks;
    }
    
    /**
     * Checks which tasks that is included in the time span
     * @param tasks: ArrayList of tasks to search from
     * @param searchObj: Task object containing the search criterias
     * @param foundTasks: Binary array with 1s for the tasks which still meets 
     * the search criteria and 0s for those who don't
     * @return the updated foundTasks array
     */
    private int[] searchOnDate(ArrayList<Task> tasks, Task searchObj, int[] foundTasks) {
        LocalDateTime startDate = searchObj.getStartDateTime();
        LocalDateTime endDate = searchObj.getEndDateTime();
        if (isDateSearch(startDate, endDate)) {
            for (int i=0; i<tasks.size(); i++) {
                Task task = tasks.get(i);
                foundTasks[i] = isTaskInInterval(task, startDate, 
                        endDate, foundTasks[i]);
            }
        }
        return foundTasks;
    }
    
    /**
     * Checks in a task is included in a given time interval 
     */
    private int isTaskInInterval(Task task, LocalDateTime searchStartDate, 
            LocalDateTime searchEndDate, int originalValue) {
        LocalDateTime taskStartDate = task.getStartDateTime();
        LocalDateTime taskEndDate = task.getEndDateTime();
        boolean startIsAfter = false;
        boolean startIsOn = false;
        boolean endIsBefore = false;
        boolean endIsOn = false;
        
        if (task.isFloatingTask()) {
            return Constants.NOT_INCLUDED_IN_SEARCH;
        } else if (task.isDeadlineTask()) {
            startIsAfter = taskEndDate.isAfter(searchStartDate);
            startIsOn = taskEndDate.equals(searchStartDate);
        } else if (task.isEventTask()) {
            startIsAfter = taskStartDate.isAfter(searchStartDate);
            startIsOn = taskStartDate.equals(searchStartDate);
        } else {
            assert false; //should never get here
        }
        endIsBefore = taskEndDate.isBefore(searchEndDate);
        endIsOn = taskEndDate.equals(searchEndDate);
        
        if (isNotInInterval(startIsAfter, startIsOn, endIsBefore, endIsOn)) {
            return Constants.NOT_INCLUDED_IN_SEARCH;
        }
        return originalValue;
    }
    
    private boolean isDateSearch(LocalDateTime startDate, LocalDateTime endDate) {
        return !(startDate.equals(LocalDateTime.MIN) && endDate.equals(LocalDateTime.MAX));
    }
    
    private boolean isNotInInterval(boolean startIsAfter, boolean startIsOn, 
            boolean endIsBefore, boolean endIsOn) {
        return !((startIsAfter || startIsOn) && (endIsBefore || endIsOn));
    }

}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageSearch.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageTest.java
	 */

public class StorageTest {
    
    StorageIO storageIO = new StorageIoMock();
    Storage storage = new Storage(storageIO);
    String fileName = System.getProperty("user.dir") + "/file_path_for_test.txt";
    
    private void initialize() {
        try {
            storage.prepareStorage();
            storage.setFilePath(fileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
        storage.deleteAll();
    }
    
    @Test
    public void setAndGetFilePath() {
        initialize();
        String newFilePath = storage.getFilePath();
        assertEquals("Check that setFilePath() updates the filePath\n", fileName, newFilePath);
    }
    
    @Test
    public void addAndGetTask() {
        initialize();
        Task testTask = new Task();
        String theDesc = "test task";
        testTask.setDescription(theDesc);
        storage.add(testTask);
        int taskId = testTask.getId();
        Task theStoredTask = storage.getTask(taskId);
        assertEquals("Check that adding and getting a task works\n", 
                theDesc, theStoredTask.getDescription());
    }
    
    @Test
    public void getLastTask() {
        initialize();
        Task testTask = new Task();
        testTask.setDescription("hej");
        storage.add(testTask);
        Task testTask2 = new Task();
        String theDesc = "test task";
        testTask2.setDescription(theDesc);
        storage.add(testTask2);
        Task lastTask = storage.getLastAddedTask();
        assertEquals("Check that getting the last added task works\n", 
                theDesc, lastTask.getDescription());
    }
    
    @Test
    public void deleteAllTasks() {
        initialize();
        Task testTask = new Task();
        testTask.setDescription("test task");
        storage.add(testTask);
        storage.deleteAll();
        String tasksFeedback = storage.getAllTasksAsString();
        assertEquals("Check that deleteAll() deletes all tasks\n", 
                Constants.MESSAGE_NO_TASKS, tasksFeedback);
    }
    
    @Test
    public void deleteTask() {
        initialize();
        Task testTask = new Task();
        testTask.setDescription("test task");
        storage.add(testTask);
        int taskId = testTask.getId();
        storage.delete(taskId);
        String tasksFeedback = storage.getAllTasksAsString();
        assertEquals("Check that delete(id) deletes the task\n", 
                Constants.MESSAGE_NO_TASKS, tasksFeedback);
    }
    
    @Test
    public void updateTaskDescription() {
        initialize();
        Task testTask = new Task();
        testTask.setDescription("test task");
        storage.add(testTask);
        int taskId = testTask.getId();
        String newDesc = "new description";
        storage.updateDescription(taskId, newDesc);
        String acctualNewDesc = storage.getTask(taskId).getDescription();
        assertEquals("Check that the description can be updated\n", 
                newDesc, acctualNewDesc);
    }
    
    private void createTask(String taskDesc, String startDateString, 
            String endDateString) {
        Task testTask = new Task();
        testTask.setDescription(taskDesc);
        if (startDateString != null) {
            LocalDateTime startDate = LocalDateTime.parse(startDateString, Constants.FORMAT_STORAGE_DATETIME);
            testTask.setStartDateTime(startDate);
        } else {
            testTask.setStartDateTime(null);
        }
        if (endDateString != null) {
            LocalDateTime endDate = LocalDateTime.parse(endDateString, Constants.FORMAT_STORAGE_DATETIME);
            testTask.setEndDateTime(endDate);
        } else {
            testTask.setEndDateTime(null);
        }
        storage.add(testTask);
    }
    
    private Task createSearchObj(String taskDesc, LocalDateTime startDate, 
            LocalDateTime endDate) {
        Task searchObj = new Task();
        searchObj.setDescription(taskDesc);
        searchObj.setStartDateTime(startDate);
        searchObj.setEndDateTime(endDate);
        return searchObj;
    }
    
    @Test
    // Search for tasks on a specific date/time
    public void searchOn() {
        initialize();
        
        String taskDesc = "search task";
        String startDateString = "15-01-2015 10:00";
        String endDateString = "15-01-2015 12:00";
        createTask(taskDesc, startDateString, endDateString);
        
        LocalDateTime startDate = LocalDateTime.parse(startDateString, Constants.FORMAT_STORAGE_DATETIME);
        LocalDateTime endDate = LocalDateTime.parse(endDateString, Constants.FORMAT_STORAGE_DATETIME);
        Task searchObj = createSearchObj("", startDate, endDate);
        String feedback = storage.search(searchObj);
        
        assertThat("Check that search shows an event starting on that time\n", 
                feedback, containsString(taskDesc));
    }
    
    @Test
    // Search after a date/time
    public void searchAfter() {
        initialize();
        
        String taskDesc = "search task";
        String startDateString = "15-01-2015 10:00";
        String endDateString = "15-01-2015 12:00";
        createTask(taskDesc, startDateString, endDateString);
        
        String searchDateString = "15-01-2015 08:00";
        LocalDateTime searchStartDate = LocalDateTime.parse(searchDateString, Constants.FORMAT_STORAGE_DATETIME);
        
        Task searchObj = createSearchObj("", searchStartDate, LocalDateTime.MAX);
        String feedback = storage.search(searchObj);
        
        assertThat("Check that search shows an event starting after that time\n", 
                feedback, containsString(taskDesc));
    }
    
    @Test
    // Search before a date/time
    public void searchBefore() {
        initialize();
        
        String taskDesc = "search task";
        String startDateString = "15-01-2015 10:00";
        String endDateString = "15-01-2015 12:00";
        createTask(taskDesc, startDateString, endDateString);
        
        String searchDateString = "15-01-2015 13:00";
        LocalDateTime searchEndDate = LocalDateTime.parse(searchDateString, Constants.FORMAT_STORAGE_DATETIME);
        
        Task searchObj = createSearchObj("", LocalDateTime.MIN, searchEndDate);
        String feedback = storage.search(searchObj);
        
        assertThat("Check that search shows an event happening before that time\n", 
                feedback, containsString(taskDesc));
    }
    
    @Test
    // Search doesn't show events happening outside of the search span
    public void searchWithoutFinding() {
        initialize();
        
        String taskDesc = "search task";
        String endDateString = "15-01-2015 12:00";
        createTask(taskDesc, null, endDateString);
        
        String searchDateString = "15-01-2015 10:00";
        LocalDateTime searchEndDate = LocalDateTime.parse(searchDateString, Constants.FORMAT_STORAGE_DATETIME);
        
        Task searchObj = createSearchObj("", LocalDateTime.MIN, searchEndDate);
        String feedback = storage.search(searchObj);
        
        assertEquals("Check that search desn't show events happening after given time\n", 
                feedback, Constants.MESSAGE_SEARCH_UNSUCCESSFUL);
    }
    
    @Test
    // Search for string
    public void searchForString() {
        initialize();
        
        String taskDesc = "search task";
        createTask(taskDesc, null, null);
        
        Task searchObj = createSearchObj("", LocalDateTime.MIN, LocalDateTime.MAX);
        String feedback = storage.search(searchObj);
        
        assertThat("Check that search can find tasks on substrings of the description\n", 
                feedback, containsString("search"));
    }
    
}
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\StorageTest.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java
	 */

public class Task implements Comparable<Task> {
	
	private static final int ID_NEW_EMPTY_TASK = -1;
	private static final int CHAR_LENGTH_DAY_OF_WEEK_DISPLAY = 3;
	private static final String EMPTY_STRING = "";
    private int id;
	private String description;
	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;
	private boolean done;
	
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java
	 */

	public Task(int i, String desc, LocalDateTime start, LocalDateTime end, boolean d) {
	    id = i;
	    description = desc;
	    startDateTime = start;
	    endDateTime = end;
	    done = d;
	}
	
	public int getId() {
		return id;
	}
	
	public String getDescription() {
		return description;
	}
	
	public LocalDateTime getStartDateTime() {
		return startDateTime;
	}
	
	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}
	
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java
	 */

	public boolean isDone() {
		return done;
	}
	
	public void setId(int _id) {
		id = _id;
	}
	
	public void setDescription(String _desc) {
		description = _desc;
	}

	public void setStartDateTime(LocalDateTime _startDateTime) {
		startDateTime = _startDateTime;
	}

	public void setEndDateTime(LocalDateTime _endDateTime) {
		endDateTime = _endDateTime;
	}
	
	public void setDone(boolean _done) {
		done = _done;
	}
    
    public boolean isEventTask() {
        if ((startDateTime != null && !startDateTime.equals(LocalDateTime.MIN)) && 
                (endDateTime != null && !endDateTime.equals(LocalDateTime.MAX))) {
            return true;
        }
        return false;
    }
    
    public boolean isDeadlineTask() {
        if ((startDateTime == null || startDateTime.equals(LocalDateTime.MIN)) && 
                (endDateTime != null && !endDateTime.equals(LocalDateTime.MAX))) {
            return true;
        }
        return false;
    }
    
    public boolean isFloatingTask() {
        if ((startDateTime == null || startDateTime.equals(LocalDateTime.MIN)) && 
                (endDateTime == null || endDateTime.equals(LocalDateTime.MAX))) {
            return true;
        }
        return false;
    }
    
    /**
     * Returns a string in tabular format with all task information formatted 
     * to be displayed to the user
     */
    public String getUserFormat() {
    	String doneImage = Constants.DISPLAY_UNDONE;
        String statusImage = EMPTY_STRING;
        if (isDone()) {
            doneImage = Constants.DISPLAY_DONE;
        }
        if (isEventTask() && isOverdue(startDateTime) && !isDone()) {
            statusImage = Constants.DISPLAY_OVERDUE;
        } else if (isDeadlineTask() && isOverdue(endDateTime) && !isDone()) {
            statusImage = Constants.DISPLAY_OVERDUE;
        }
        String feedback = String.format(Constants.DISPLAY_TASK_FORMAT, 
                getId(), statusImage, doneImage, getDateTimeForDisplay(this.getStartDateTime()), 
                getDateTimeForDisplay(this.getEndDateTime()), getDescription());
        return feedback;
    }
    
    private boolean isOverdue(LocalDateTime timeToCheck) {
        LocalDateTime timeNow = LocalDateTime.now();
        return timeToCheck.isBefore(timeNow);
    }
	
	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java
	 */

	@Override
	public int compareTo(Task compareTask) {
	    LocalDateTime compEndDateTime = compareTask.getEndDateTime();
	    
	    if (endDateTime != null && compEndDateTime != null) {
	        int diffMinutes = (int) ChronoUnit.MINUTES.between(endDateTime, compEndDateTime);
	        return diffMinutes;
	    } else if (endDateTime != null && compEndDateTime == null) {
	        return 1;
	    } else if (endDateTime == null && compEndDateTime != null) {
	        return -1;
	    } else {
	        return 0;
	    }
	}
	
}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\Task.java





	/**
	 * origin: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\UI.java
	 */

public class UI {
    
    private static Scanner scanner = new Scanner(System.in);
    private static Logic mainLogic;
    
    public static void main(String[] args) {
    	mainLogic = Logic.getLogicObject();
        String initializationMessage = initializeEnvironment();
        showToUser(initializationMessage);
        while (true) {
            System.out.print("\nEnter command: ");
            String userCommand = scanner.nextLine();
            String feedback = mainLogic.execute(userCommand);
            showToUser(feedback);
        }
    }
    
    private static String initializeEnvironment() {
        String initializationMessage = Constants.MESSAGE_WELCOME;
        initializationMessage += "\n" + mainLogic.initializeEnvironment();
        initializationMessage += "\n" + "Your tasks for this week:";
        initializationMessage += "\n" + mainLogic.execute("display");
        return initializationMessage;
    }
    
    private static void showToUser(String message) {
        System.out.println(message);
    }
    
}

	// End of segment: C:\Users\Luq\workspace\TaskWaltz\main\CS2103_gtd\src\UI.java





